using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;

namespace MissivesSynthesisPatcher
{
    // Represents a single removal rule for filtering form list items
    public class RemovalRule
    {
        public string EditorID { get; set; } = string.Empty;
        // Optional plugin filter to restrict removal to specific mods
        public List<string>? Plugins { get; set; }
    }

    public class PatcherSettings
    {
        public List<RemovalRule> EditorIdsToRemove { get; set; } = new();
    }

    public class Program
    {
        // Lazy initialization to avoid loading settings until pipeline needs them
        static Lazy<PatcherSettings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var settings = Settings.Value;
            // Track removed items for summary report at the end
            var removedItems = new List<(string FormlistEditorID, string ItemEditorID, string ItemFormKey)>();
            
            Console.WriteLine($"Rules to apply: {settings.EditorIdsToRemove.Count}");
            foreach (var rule in settings.EditorIdsToRemove)
            {
                // Display plugin restriction if specified, otherwise apply rule globally
                var pluginInfo = rule.Plugins != null && rule.Plugins.Count > 0 
                    ? $" from plugins: {string.Join(", ", rule.Plugins)}"
                    : "";
                Console.WriteLine($"  - EditorID: {rule.EditorID}{pluginInfo}");
            }

            foreach (var formlistGetter in state.LoadOrder.PriorityOrder.FormList().WinningOverrides())
            {
                Console.WriteLine($"\nProcessing formlist: {formlistGetter.EditorID}");
                Console.WriteLine($"Items before: {formlistGetter.Items.Count}");

                for (int i = 0; i < formlistGetter.Items.Count; i++)
                {
                    var itemFormKey = formlistGetter.Items[i].FormKey;
                    var itemRecord = state.LinkCache.Resolve(itemFormKey);
                    var itemEditorID = itemRecord.EditorID ?? "";
                    Console.WriteLine($"  {i}: {itemFormKey} ({itemEditorID})");
                }

                int removedCount = 0;
                // Store indices instead of removing directly to avoid index shifting during iteration
                var itemsToRemove = new List<int>();
                
                // Iterate backwards to safely identify removal candidates
                for (int i = formlistGetter.Items.Count - 1; i >= 0; i--)
                {
                    var itemFormKey = formlistGetter.Items[i].FormKey;
                    var itemRecord = state.LinkCache.Resolve(itemFormKey);
                    var itemEditorID = itemRecord.EditorID ?? "";
                    var itemPlugin = itemFormKey.ModKey.FileName.String;

                    foreach (var rule in settings.EditorIdsToRemove)
                    {
                        bool editorIdMatches = itemEditorID.Contains(rule.EditorID, StringComparison.OrdinalIgnoreCase);
                        // Plugins are optional; null or empty means match all plugins
                        bool pluginMatches = rule.Plugins == null || rule.Plugins.Count == 0 || 
                            rule.Plugins.Any(p => itemPlugin.Equals(p, StringComparison.OrdinalIgnoreCase));

                        if (editorIdMatches && pluginMatches)
                        {
                            Console.WriteLine($"Removing: {itemFormKey} ({itemEditorID}) from plugin '{itemPlugin}'");
                            removedItems.Add((formlistGetter.EditorID ?? "Unknown", itemEditorID, itemFormKey.ToString()));
                            itemsToRemove.Add(i);
                            removedCount++;
                            break;
                        }
                    }
                }

                if (removedCount > 0)
                {
                    // Create override only when modifications are needed to minimize patch size
                    var formlistOverride = state.PatchMod.FormLists.GetOrAddAsOverride(formlistGetter);
                    // Remove in descending order to prevent index invalidation
                    foreach (var index in itemsToRemove.OrderByDescending(x => x))
                    {
                        formlistOverride.Items.RemoveAt(index);
                    }
                }

                Console.WriteLine($"Items removed: {removedCount}");
                Console.WriteLine($"Items after: {formlistGetter.Items.Count - removedCount}");
            }

            // Print summary
            Console.WriteLine($"\n{'='} REMOVAL SUMMARY {'='}\n");
            if (removedItems.Count == 0)
            {
                Console.WriteLine("No items were removed.");
            }
            else
            {
                Console.WriteLine($"Total items removed: {removedItems.Count}\n");
                var groupedByFormlist = removedItems.GroupBy(x => x.FormlistEditorID);
                foreach (var group in groupedByFormlist)
                {
                    Console.WriteLine($"From formlist '{group.Key}':");
                    foreach (var item in group)
                    {
                        Console.WriteLine($"  - {item.ItemFormKey} ({item.ItemEditorID})");
                    }
                    Console.WriteLine();
                }
            }
        }
    }
}

